课程地址： https://www.bilibili.com/video/BV13g41157hK?p=1

# 基础

### 复杂度

常数时间的操作：一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用0(读作big 0)来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。

在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那么时间复杂度为0(f(N))。

评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。



### 位运算

**^ 运算符理解**

- ^ 可理解为不进位相加
- a^a=0
- a^0=a
- 异或运算满足交换律和结合率

与 & ；或 | ；异或 ^ ；取反 ~ ；



##### 不用额外变量交换两个数

```java
public static void sway(int[] arr,int i,int j){
	if(i!=j){
		//不能两个值指向同一地址
	    arr[i]=arr[i]^arr[j];
	    arr[j]=arr[i]^arr[j];//就是arr[i]^arr[j]^arr[j]就表示a
	    arr[i]=arr[i]^arr[j];//表示arr[i]^arr[j]^arr[i]^arr[j]^arr[j]就是b
    }
}
```



##### 寻找出现双中的单数

题目：一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数

```java
public class Main {
	private static int process(int[] arr) {
		int res = 0;
		for (int i : arr) {
			res ^= i;
		}
		return res;
	}
}
```



##### 取出一个数最右边1的位置

```java
int mostRightOne = pos & (~pos + 1); 
// mostRightOne值在二进制位上的位次就是pos得最右第一个1的位置
```



##### 找所有双出现中的两个单数

题目：一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数

- 因为两个值不同，所以两个值定存在二进制某一位定不同，用这两个值的异或结果二进制中的1，从而将数字分成两组，该位为1和不为1

```java
public class Main {
	private static void process(int[] arr) {
		int med = 0;
		for (int a : arr) {
			med ^= a;// 两个不同的单数^最后得到med
		}
		int rightOne = med & (~med + 1);// 取出med中二进制为1的位值（必存在，因为不同值）
		int med1 = 0;
		for (int a : arr) {
			// 对应位为1的值取出进行^最后的到两个单数对应位为1的
			// (a&rightOne)== 0得到对应位为0
			if ((a & rightOne) == rightOne) {
				med1 ^= a;
			}
		}
		System.out.println(med1);// 两个单数其中一个值
		System.out.println(med ^ med1);// 两个单数令一个值
	}
}
```



### 对数器

对数器的概念和使用
1，有一个你想要测的方法a
2，实现复杂度不好但是容易实现的方法b3，实现一个随机样本产生器
4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。
5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b
6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。





### 排序

##### 冒泡排序

时间复杂度O(N^2)，额外空间复杂度0(1)



##### 简单选择排序

时间复杂度O(N^2)，额外空间复杂度0(1)



##### 插入排序

时间复杂度O(N^2)，额外空间复杂度0(1)
算法流程按照最差情况来估计时间复杂度



##### 二分法

1）在一个有序数组中，找某个数是否存在
2）在一个有序数组中，找>=某个数最左侧的位置
3）局部最小值问题



##### 递归

用递归方法找一个数组中的最大值

master公式的使用 

T(N) = a*T(N/b) + O(N^d) 
1) log(b,a) > d -> 复杂度为O(N^log(b,a)) 
2) log(b,a) = d -> 复杂度为O(N^d * log N) 
3) log(b,a) < d -> 复杂度为O(N^d)

补充阅读： [算法的复杂度与 Master 定理 · GoCalf Blog](https://blog.gocalf.com/algorithm-complexity-and-master-theorem) 



##### 归并排序

1）整体就是一个简单递归，左边排好序、右边排好序、让其整体有序 
2）让其整体有序的过程里用了排外序方法 
3）利用master公式来求解时间复杂度 
4）归并排序的实质 

时间复杂度O(N*log N)，额外空间复杂度O(N)



























































































